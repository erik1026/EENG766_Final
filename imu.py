# This file contains all the functions related to the mechanization of the imu
import numpy as np
import pickle as pkl
from create_truth import vec2ss, v2R, R2v, CreateSim, FOGM
import scipy.sparse as sp
from math import sqrt, acos
import scipy.linalg as la
import scipy.sparse.linalg as spla
import copy
import matplotlib.pyplot as plt
# import create_truth # needed to know how to handle scenario ... I believe

def to_rot(R):
    u,s,vh = la.svd(R)
    return u.dot(vh)

def trace(R):
    return np.sum(np.diag(R))

def J_logm(R):
    '''
    This is an implementation of the log of the SO3 from:
    http://ingmec.ual.es/~jlblanco/papers/jlblanco2010geometry3D_techrep.pdf
    Sections 10.3.2

    Returns a 3x3x3 numpy array

    Note that the "J" matrix seems backwards from the paper as the paper lists 
    things in "column major" order, while numpy is row-major

    Also note, from (7.5), that they define the hat operator backwards of the way 
    I do, therefore, I negate everything going out
    '''
    J = np.zeros((3,9))
    cos_th = (trace(R) - 1.)/2.
    if cos_th > .9999999:
        J = np.array([[[0,0,0.],[0,0,-.5],[0,.5,0]],
                      [[0,0,.5],[0,0,0],[-.5,0,0]],
                      [[0,-.5,0],[.5,0,0],[0,0,0.]]])
        return -J
    
    sin_th = sqrt(1-cos_th**2)
    th = acos(cos_th)
    a = np.zeros(3)
    a_scalar = (th * cos_th - sin_th)/(4*sin_th**3.)
    a[0] = R[2,1]-R[1,2]
    a[1] = R[0,2]-R[2,0]
    a[2] = R[1,0]-R[0,1]
    a *= a_scalar
    b = th/(2*sin_th)

    J = np.array([[[a[0], 0, 0],[0,a[0],-b],[0,b,a[0]]],
                [[a[1], 0, b],[0,a[1],0],[-b,0,a[1]]],
                [[a[2], -b, 0],[b, a[2],0], [0,0,a[2]]]])
    return -J

def log_J_to_vec(J_logm_stored, dR_dv):
    '''
    This function takes a 3d numpy array produced by J_logm and
    a matrix of how R changes w.r.t. some scalar value and produces
    a vector of how the R2v will change w.r.t. that scalar.

    The function is pretty simple, but better than re-writing lots of times

    Args:
        J_logm_stored: the 3d array generated by the J_logm function
        dR_dv: a 2d array with the derivatives of R (the same one originally
                passed into J_logm) w.r.t. some scalar

    Returns: a (3,) numpy array with the derivatives of R2v of the rotation 
        w.r.t. the scalar
    '''
    going_out = np.zeros(3)
    for i in range(3):
        going_out[i] = np.sum(dR_dv * J_logm_stored[i])
    return going_out

def test_deriv(hwp, dx_idx,step=.001, a_tol=1E-5, r_tol=1E-3):
    '''Tests to make sure
    the create_A and create_y are doing 
    the same thing.

    Returns a tuple with:
    * A boolean saying whether it passed
    * the numerical derivative
    * the computed derivative
    '''
    A = hwp.create_A()
    width = A.shape[1]
    dx = np.zeros(width)
    dx[dx_idx]= step
    y_orig=hwp.create_y()
    state_diff = copy.deepcopy(hwp)
    state_diff.add_delta(dx)
    y_next = state_diff.create_y()
    num_deriv = (y_orig-y_next)/step
    comp_deriv = A[:,dx_idx]
    if sp.issparse(comp_deriv):
        comp_deriv=comp_deriv.toarray().flatten()
    good = np.allclose(num_deriv,comp_deriv,atol=a_tol,rtol=r_tol)
    return (good,num_deriv,comp_deriv)


def create_ij(offset,shape):
    '''
    This function is to create the "rows" and "cols" that will
    be used to index a matrix of size "shape" if the offset is
    passed in. To create a sparse matrix, you can flatten the array
    and use the output of this function to give you the rows and columns

    Args:
        offset:  a 2-element set of ints denoting what the offset will be for
            the matrix object.  Should be (row,col)
        shape:   how big is this thing that is being put in there.  Assumed 2d

    Returns:  a tuple of n-element, 1d numpy arrays, where n is shape[0]*shape[1]
    '''
    assert len(shape)==2, 'create_ij only works for 2d arrays'
    full_len = shape[0]*shape[1]
    rows = np.zeros(full_len)
    cols = np.zeros(full_len)
    for i in range(shape[0]):
        rows[i*shape[1]:(i+1)*shape[1]]=i
        cols[i*shape[1]:(i+1)*shape[1]]=np.arange(shape[1])
    return (rows+offset[0],cols+offset[1])


class imu_model:

    ss0 = vec2ss(np.array([1.,0,0]))
    ss1 = vec2ss(np.array([0,1.,0]))
    ss2 = vec2ss(np.array([0,0,1.]))
    sss = np.array([ss0,ss1,ss2])

    def __init__(self, scen, n_ts=None):
        self.scen = scen
        self.dt = scen.dt
        # grab the h and H functions
        self.h = scen.h 
        self.H = scen.H
        # get the covariance data from the scen
        R = scen.params['R']
        self.s_R_inv = 1/sqrt(R)
        ## gyro
        gyro = scen.params['gyroFOGM']
        self.s_grw_inv = 1/gyro.rw
        self.gyro_tau = gyro.tau
        self.s_gbrw_inv = 1/(gyro.bias_rw*sqrt(self.dt))
        ## accel
        accel = scen.params['accelFOGM']
        self.s_arw_inv = 1/accel.rw
        self.accel_tau = accel.tau
        self.s_abrw_inv = 1/(accel.bias_rw*sqrt(self.dt))
        # Won't actually use all of the truth positions.
        if n_ts is None:
            self.n_ts = len(scen.positions)-1
        else:
            self.n_ts = n_ts
        # May need to think about a smarter initialization, but for now...
        self.positions = np.zeros((self.n_ts,3))
        self.velocities = np.zeros((self.n_ts,3))
        self.attitudes = np.zeros((self.n_ts,3,3))

        for i in range(self.n_ts):
            self.attitudes[i] = np.eye(3)
        self.g_biases = np.zeros((self.n_ts,3)) #gyro biases
        self.a_biases = np.zeros((self.n_ts,3)) #accel biases

        # My "Fancy" initialization
        self.positions = copy.copy(scen.positions[:self.n_ts])
        self.velocities = copy.copy(scen.velocities[:self.n_ts])
        self.attitudes = copy.copy(scen.b_C_ns[:self.n_ts])
        # for i in range(self.n_ts-1):
        #     pos,vel,att,_,_ = self.f(i)
        #     self.positions[i] = pos
        #     self.velocities[i] = vel
        #     self.attitudes[i] = att

        # Need something to describe noise on the system, besides the
        # gyro and accel noise
        self.s_pos_rw_inv = 1000 # really small standard deviation, 
        # Now create the s_Q_inv matrix
        sQI = np.zeros((15,15))
        ## easy first .. biases
        sQI[-3:,-3:] = np.eye(3)*self.s_abrw_inv
        sQI[-6:-3, -6:-3] = np.eye(3)*self.s_gbrw_inv
        # velocity terms
        sQI[3:6,3:6] = np.eye(3) * self.s_arw_inv
        # attitude
        sQI[6:9,6:9] = np.eye(3)* self.s_grw_inv
        sQI[:3,:3] = np.eye(3) * self.s_pos_rw_inv
        self.s_Q_inv = sQI


    def f(self,idx):
        '''
        Propagate the "idx" timestep forward to predict its
        location at time idx+1

        Returns a tuple with (position, velocity, attitude, gyro bias, accel bias)
        '''
        g_bias = self.g_biases[idx] * (1-self.dt/self.gyro_tau)
        a_bias = self.a_biases[idx] * (1-self.dt/self.accel_tau)
        att= copy.copy(self.attitudes[idx])
        vel = copy.copy(self.velocities[idx])
        pos = copy.copy(self.positions[idx])
        divider = 1
        my_dt = self.dt/float(divider)
        grav = self.scen.n_grav
        for i in range(divider):
            next_vel = vel + my_dt*(grav + att.T.dot(self.scen.accels[idx]-self.a_biases[idx]))
            pos += (next_vel+vel)/2 * my_dt
            att = v2R(my_dt*(self.scen.gyros[idx]-self.g_biases[idx])).dot(att)
            vel = next_vel
        # Just for kicks, though probably not needed
        att = to_rot(att)
        return (pos,vel,att,g_bias,a_bias)
        

    
    def compute_F(self,idx):
        '''
        Take self.positions[idx], velocities, etc and compute the F for 
        that state estimate

        Args: idx: which state vector to predict to idx+1

        Returns:
        A 15x30 numpy array
        '''
        F = np.zeros((15,30))
        # Easy first ... biases
        ## accels
        F[-3:,12:15] = (1-self.dt/self.accel_tau)*np.eye(3)
        F[-3:,-3:] = -np.eye(3)
        ## gyros
        F[-6:-3,9:12] = (1-self.dt/self.gyro_tau)*np.eye(3)
        F[-6:-3,-6:-3] = -np.eye(3)
        
        # Now for attitude
        ## The measurement is going to be 
        ## R2v(C_k^T C_gyro^T C_{k+1}(estimated))
        ## First take the derivative of the log w.r.t the whole matrix inside
        R_gyro = v2R(self.dt*(self.scen.gyros[idx]-self.g_biases[idx]))
        big_R = self.attitudes[idx].T.dot(R_gyro.T.dot(self.attitudes[idx+1]))
        JR = J_logm(big_R)
        ## Now take the derivative of R w.r.t the state vector parts and 
        ## Do an element-by-element multiply with JR to get the complete derivative
        ### w.r.t. b_g
        for j in range(3):
            # The negative and the transpose cancel, I think...
            dbig_R_d_gyro = self.attitudes[idx].T.dot(self.sss[j].dot(self.attitudes[idx+1]))
            F[6:9,9+j] = log_J_to_vec(JR,self.dt*dbig_R_d_gyro)
        
        ### w.r.t C_k (estimated)
        for j in range(3):
            dbig_R_d_C_k = -self.sss[j].dot(big_R)
            F[6:9,6+j] = log_J_to_vec(JR,dbig_R_d_C_k)

        ### measurement w.r.t. C_{k+1} estimated
        for j in range(3):
            dbig_R_d_C_kp1 = big_R.dot(self.sss[j])
            F[6:9,21+j]= log_J_to_vec(JR,dbig_R_d_C_kp1)

        # Velocity!
        ## w.r.t. v_k
        F[3:6,3:6] = np.eye(3)
        D = np.eye(3) #v2R(self.dt/2. * (self.scen.gyros[idx]-self.g_biases[idx]))
        ## w.r.t. b_C_n
        for j in range(3):
            F[3:6,j+6] = -self.dt*\
                self.sss[j].dot(self.attitudes[idx].T.dot(D.T).dot(self.scen.accels[idx]-self.a_biases[idx]))
        ## w.r.t. gyro biases
        # for j in range(3):
        #     F[3:6,j+9] = (self.dt**2)/2.0*\
        #         self.attitudes[idx].T.dot(self.sss[j]).dot(self.scen.accels[idx]-self.a_biases[idx])
        F[3:6,9:12] = np.zeros((3,3))
        ## w.r.t. accel biases.        
        F[3:6,12:15] = -self.dt*self.attitudes[idx].T.dot(D.T)

        F[3:6,18:21] = -np.eye(3)

        # Position!
        ## w.r.t. x_k
        F[:3,:3] = np.eye(3)
        F[:3,15:18] = -np.eye(3)
        ## w.r.t v_k
        F[:3,3:6] = self.dt*np.eye(3)
        ## Take the velocity terms and multiply times 1/2 dt
        F[:3,6:15] = self.dt/2. * F[3:6,6:15]

        return F

    def create_A(self):
        # To model the state, we are going to have
        # * position
        # * velocity
        # * attitude
        # * gyro bias
        # * accel bias
        # for each time step
        sens_meas = len(self.scen.landmark_locs)*self.n_ts
        n_rows = sens_meas +(self.n_ts-1)*15
        n_cols = self.n_ts *15
        n_meas_entries = 3*sens_meas

        # Let's do the derivatives of the measurements
        meas_entries = np.zeros(n_meas_entries)
        meas_rows = np.zeros(n_meas_entries)
        meas_cols = np.zeros(n_meas_entries)
        ms = 3*len(self.scen.landmark_locs) # measurement size
        for i in range(self.n_ts):
            m_idx = i*ms # meas_idx
            H = self.H(self.positions[i])
            meas_entries[m_idx:m_idx+ms] = self.s_R_inv*H.flatten()
            offset = (i*len(self.scen.landmark_locs), i*15)
            rows,cols = create_ij(offset,H.shape)
            meas_rows[m_idx:m_idx+ms] = rows
            meas_cols[m_idx:m_idx+ms] = cols
        

        # Dynamics matrix, here we come...
        # * 15x3, position -- 45
        # * 12x3, velocity -- 36 (running total: 81)
        # * 6x3, attitude -- 18 (running total: 99)
        # * 3x3, gyro bias -- 9 (running total: 108)
        # * 3x3, accel bias -- 9 (running total: 117)
        # * identity on the other side -- 15 (assuming Q is diagonal) 
        # (running total: 132)
        # Or, the simpler is just to assume two 15x15 matrices (225x2 = 450)
        # I'm going for the second because it is just easier.
        ds = 450 #dynamics size...
        n_dyn_entries = (self.n_ts-1)*ds
        dyn_entries = np.zeros(n_dyn_entries)
        dyn_rows = np.zeros(n_dyn_entries)
        dyn_cols = np.zeros(n_dyn_entries)
        
        for i in range(self.n_ts-1):
            F = self.s_Q_inv.dot(self.compute_F(i))
            offset = (sens_meas+i*15,i*15)
            rows,cols = create_ij(offset,F.shape)
            dyn_entries[i*450:i*450+450] = F.flatten()
            dyn_rows[i*450:i*450+450] = rows
            dyn_cols[i*450:i*450+450] = cols
        
        entries = np.concatenate((meas_entries,dyn_entries))
        sp_rows= np.concatenate((meas_rows,dyn_rows))
        sp_cols= np.concatenate((meas_cols,dyn_cols))

        return sp.csr_matrix((entries,(sp_rows,sp_cols)), shape=(n_rows,n_cols))

    def create_y(self):
        sens_meas = len(self.scen.landmark_locs)*self.n_ts
        n_rows = sens_meas +(self.n_ts-1)*15

        y = np.zeros(n_rows)
        # Start with sensor measurements
        mpts = len(self.scen.landmark_locs) #measurements per time step
        for i in range(self.n_ts):
            y[i*mpts:i*mpts+mpts]= self.s_R_inv*(self.scen.meas[i] - self.h(self.positions[i]))
        
        # Now for dynamics measurements
        dyn_st = sens_meas
        dyn_cost = np.zeros(15)
        for i in range(self.n_ts-1):
            pred_x = self.f(i)
            dyn_cost[:3] = pred_x[0]-self.positions[i+1]
            dyn_cost[3:6] = pred_x[1] - self.velocities[i+1]
            dyn_cost[6:9] = R2v(pred_x[2].T.dot(self.attitudes[i+1]))
            dyn_cost[9:12] = pred_x[3] - self.g_biases[i+1]
            dyn_cost[12:15] = pred_x[4] - self.a_biases[i+1]
            y[dyn_st+i*15:dyn_st+i*15+15] = -self.s_Q_inv.dot(dyn_cost)

        return y

    def add_delta(self,delta):
        '''
        This function takes in a delta from solving A \Delta = y 
        (with A and y created by create_A and create_y) and 
        modifies the internal state with the delta.

        Args: delta: a (15*self.num_ts) numpy vector that should change the state

        Returns:  Nothing.  Only changes the internal state
        '''
        assert len(delta) == 15*self.n_ts
        for i in range(self.n_ts):
            si = i*15 # starting index
            self.positions[i] += delta[si:si+3]
            self.velocities[i] += delta[si+3:si+6]
            self.attitudes[i] = self.attitudes[i].dot(v2R(delta[si+6:si+9]))
            self.g_biases[i] += delta[si+9:si+12]
            self.a_biases[i] += delta[si+12:si+15]