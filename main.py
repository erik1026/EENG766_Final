# This file will contain the main simulation class
from numpy.lib.shape_base import _put_along_axis_dispatcher
import imu as imu
import visual as vis
import numpy as np
import sys
import math as m
import copy 
import matplotlib.pyplot as plt
import rot as rot
from create_truth import R2v, v2R
import scipy.sparse.linalg as spla
import scipy.linalg as la
from utils import create_skew_symm_mat
from create_truth import vec2ss
import scipy.sparse as sp

 

def to_rot(R):
    u,s,vh = la.svd(R)
    return u.dot(vh)

def trace(R):
    return np.sum(np.diag(R))

def create_ij(offset,shape):
    '''
    This function is to create the "rows" and "cols" that will
    be used to index a matrix of size "shape" if the offset is
    passed in. To create a sparse matrix, you can flatten the array
    and use the output of this function to give you the rows and columns

    Args:
        offset:  a 2-element set of ints denoting what the offset will be for
            the matrix object.  Should be (row,col)
        shape:   how big is this thing that is being put in there.  Assumed 2d

    Returns:  a tuple of n-element, 1d numpy arrays, where n is shape[0]*shape[1]
    '''
    assert len(shape)==2, 'create_ij only works for 2d arrays'
    full_len = shape[0]*shape[1]
    rows = np.zeros(full_len)
    cols = np.zeros(full_len)
    for i in range(shape[0]):
        rows[i*shape[1]:(i+1)*shape[1]]=i
        cols[i*shape[1]:(i+1)*shape[1]]=np.arange(shape[1])
    return (rows+offset[0],cols+offset[1])

def J_logm(R):
    '''
    This is an implementation of the log of the SO3 from:
    http://ingmec.ual.es/~jlblanco/papers/jlblanco2010geometry3D_techrep.pdf
    Sections 10.3.2

    Returns a 3x3x3 numpy array

    Note that the "J" matrix seems backwards from the paper as the paper lists 
    things in "column major" order, while numpy is row-major

    Also note, from (7.5), that they define the hat operator backwards of the way 
    I do, therefore, I negate everything going out
    '''
    J = np.zeros((3,9))
    cos_th = (trace(R) - 1.)/2.
    if cos_th > .9999999:
        J = np.array([[[0,0,0.],[0,0,-.5],[0,.5,0]],
                      [[0,0,.5],[0,0,0],[-.5,0,0]],
                      [[0,-.5,0],[.5,0,0],[0,0,0.]]])
        return -J
    
    sin_th = m.sqrt(1-cos_th**2)
    th = m.acos(cos_th)
    a = np.zeros(3)
    a_scalar = (th * cos_th - sin_th)/(4*sin_th**3.)
    a[0] = R[2,1]-R[1,2]
    a[1] = R[0,2]-R[2,0]
    a[2] = R[1,0]-R[0,1]
    a *= a_scalar
    b = th/(2*sin_th)

    J = np.array([[[a[0], 0, 0],[0,a[0],-b],[0,b,a[0]]],
                [[a[1], 0, b],[0,a[1],0],[-b,0,a[1]]],
                [[a[2], -b, 0],[b, a[2],0], [0,0,a[2]]]])
    return -J

def log_J_to_vec(J_logm_stored, dR_dv):
    '''
    This function takes a 3d numpy array produced by J_logm and
    a matrix of how R changes w.r.t. some scalar value and produces
    a vector of how the R2v will change w.r.t. that scalar.

    The function is pretty simple, but better than re-writing lots of times

    Args:
        J_logm_stored: the 3d array generated by the J_logm function
        dR_dv: a 2d array with the derivatives of R (the same one originally
                passed into J_logm) w.r.t. some scalar

    Returns: a (3,) numpy array with the derivatives of R2v of the rotation 
        w.r.t. the scalar
    '''
    going_out = np.zeros(3)
    for i in range(3):
        going_out[i] = np.sum(dR_dv * J_logm_stored[i])
    return going_out

class FOGM:
    def __init__(self, rw, num_sensors=1, bias_rw=None, bias_tau=None, init_sd=None):
        '''
        Creates a class that implements (num_sensors independent) 
        First Order Gauss Markov Processes (FOGM).  The model
        assumes error = N(0,rw^2) + b
        where \dot{b} = -\frac{1}{bias_tau}b + nu
        where nu = N(0,bias_rw^2)
        init_sd is what standard deviation to use to get the initial bias.
        By default it should be equal to the "steady state" variance of the FOGM

        Args:
            rw:  standard deviation of white noise
            num_sensors:  How many of these things to track in this class
            bias_rw:  the standard deviation of the additive white noise for 
                the bias part (random walk)
            bias_tau: the time constant for the FOGM
            init_sd: the standard deviation of the initial bias

        '''
        self.rw = rw
        assert (bias_rw is None and bias_tau is None) or\
            (bias_rw is not None and bias_tau is not None), \
                "Need both bias_tau and bias_rw, or neither."
        self.biased = bias_rw is not None
        if self.biased and init_sd is None:
            init_sd = m.sqrt(bias_tau)*bias_rw
        
        self.bias_rw = bias_rw
        self.tau = bias_tau

        self.ns = num_sensors

        if self.biased:
            self.bias = np.random.randn(num_sensors)*init_sd
        else:
            self.bias = np.zeros(num_sensors)

    def sample(self,dt):
        '''
        Returns a sample from the FOGM random process.  Basically,
        it returns a random value and propagates the bias states forward
        dt time
        '''
        going_out = np.random.randn(self.ns)*self.rw + self.bias
        if self.biased:
            self.bias = self.bias*(1-dt/self.tau) + \
                np.random.randn(self.ns)*self.bias_rw*m.sqrt(dt)
        return going_out

class sim_world:
    '''
        Our simulated world environment. It is relatively simple, only contains the world points that represent 
        our object of interest, a single camera, and the imu.

        world_pts: a (nx3) array that contains the x,y,z coordinates of each world point
        cam: The camera that will be used to capture images
        imu: model of an imu that will be used for the optimization
        cam_pos: a (nx3) array that contains all the positions that the camera will move to throughout the flight
        cam_rot: a (nx3) array that contains all the euler angles for the cameras rotation about our world_pts
    '''
    ss0 = vec2ss(np.array([1.,0,0]))
    ss1 = vec2ss(np.array([0,1.,0]))
    ss2 = vec2ss(np.array([0,0,1.]))
    sss = np.array([ss0,ss1,ss2])
    def __init__(self,imu=None, scenerio=None, world_pts=None): 
        # If no world points are passed in then we'll create a rectangular prism to work with
        self.n_pos = 36 # 360/10 = 36 waypoints
        self.n_ts = self.n_pos - 1
        self.world_pts = np.array([[-.5, -.5, 0.5], [.5,-.5,0.5],[-.5,.5,0.5],
                                    [.5,.5,0.5], [-.5,-.5,1], [.5,-.5,1],
                                    [-.5,.5,1], [.5,.5,1]]) 
        
        # Create a camera for the system
        self.cam = vis.Camera()

        gyro_rw = .0001 # radians / s
        gyro_tau = 20 # s
        gyro_bias_rw = .00001
        
        accel_rw = .001 # m/s^2
        accel_tau = 100 # s
        accel_bias_rw = .0001
    
        R = 1.
        self.s_R_inv = 1/m.sqrt(R)

        self.gyro_noise = FOGM(gyro_rw, 3, gyro_bias_rw, gyro_tau)
        self.accel_noise = FOGM(accel_rw, 3, accel_bias_rw, accel_tau)
        self.dt = 1.
        self.n_grav = np.array([0,0.,9.8])

        ## gyro
        self.s_grw_inv = 1/self.gyro_noise.rw
        self.gyro_tau = self.gyro_noise.tau
        self.s_gbrw_inv = 1/(self.gyro_noise.bias_rw*m.sqrt(self.dt))
        ## accel
        self.s_arw_inv = 1/self.accel_noise.rw
        self.accel_tau = self.accel_noise.tau
        self.s_abrw_inv = 1/(self.accel_noise.bias_rw*m.sqrt(self.dt))

        self.g_biases = np.zeros((self.n_ts,3)) #gyro biases
        self.a_biases = np.zeros((self.n_ts,3)) #accel biases

        self.s_pos_rw_inv = 1000 # really small standard deviation, 
        # Now create the s_Q_inv matrix
        sQI = np.zeros((15,15))
        ## easy first .. biases
        sQI[-3:,-3:] = np.eye(3)*self.s_abrw_inv
        sQI[-6:-3, -6:-3] = np.eye(3)*self.s_gbrw_inv
        # velocity terms
        sQI[3:6,3:6] = np.eye(3) * self.s_arw_inv
        # attitude
        sQI[6:9,6:9] = np.eye(3)* self.s_grw_inv
        sQI[:3,:3] = np.eye(3) * self.s_pos_rw_inv
        self.s_Q_inv = sQI

        '''
        Create a series of positions for the camera that rotate the camera around the 
        object in a circle.Places the camera at a height of 5 meters and backs up until all the object points are 
        frame then finally angles the camera such that the center of mass of the object is in the center of
        the frame.
        '''
        # Truth
        self.cam_pos = np.zeros((self.n_pos, 3)) # w_Cam : Position of cam in world frame
        self.cam_rot = [] # c_R_w : Rotation from world frame to camera frame
        self.cam_vel = np.zeros((self.n_pos - 1, 3)) # Velocity in world frame
        self.gyros = np.zeros((self.n_pos-1, 3))
        self.accels = np.zeros((self.n_pos-1, 3))
        self.cam.set_rot(rot.axis0(-90, True).dot(rot.axis1(0, True).dot(rot.axis2(90, True))))
        self.radius = 8.
        self.z_offset = .5
        
        # Compute Camera positions and rotations
        tmp_offset = copy.deepcopy(self.cam.w_cam)
        for i in range(self.n_pos ):
            angle = ( (2*m.pi) / 36 ) * i
            self.cam_pos[i] = np.array([m.cos(angle)*self.radius, m.sin(angle)*self.radius, self.z_offset])
            
            self.cam_rot.append( ((self.cam.c_R_w).dot(rot.axis2(angle))) )

        self.positions = np.zeros((self.n_ts, 3))
        self.positions = copy.copy(self.cam_pos[:self.n_ts])
        self.rotations = np.zeros((self.n_ts, 3))
        self.rotations = copy.copy(self.cam_rot[:self.n_ts])

        # Compute Camera Velocities
        self.V = (2*m.pi*self.radius) / self.n_pos
        for i in range(self.n_pos - 1):
            self.cam_vel[i] = self.cam_rot[i].T.dot(np.array([self.V, 0., 0.])) # In the navigation frame
        
        self.velocities = np.zeros((self.n_ts, 3))
        self.velocities = copy.copy(self.cam_vel[:self.n_ts])

        for i in range(self.n_pos-1):
            ## compute gyros
            dR = self.cam_rot[i+1].dot(self.cam_rot[i].T)
            self.gyros[i] = R2v(dR)/self.dt + self.gyro_noise.sample(self.dt)
            ## Really, the accels are two steps back as velocity is one
            ## step back and accel is one behind it.  However, I just
            ## leave 0's in there if data is not there yet.
            if i > 0:  #Don't go too far back
                ## compute accels
                n_dV = self.cam_vel[i]-self.cam_vel[i-1]
                accel_true = n_dV/self.dt - self.n_grav
                self.accels[i-1] = self.cam_rot[i-1].dot(accel_true) + self.accel_noise.sample(self.dt)

    def compute_h(self):
        '''
        Computes the measurements for the given systems world points, camera locations, rotations, and camera parameters

        Args: None

        Returns: meas - numpy array containing the pure pixel measurements
                 meas_w_noise - numpy array containing pixel measurements with added noise from normal distribution
        '''
        num_world_points = self.world_pts.shape[0]
        meas = np.zeros((self.n_pos * num_world_points, 2)) # n measurements and m world points that produce an u and v
        meas_w_noise = np.zeros((self.n_pos * num_world_points, 2))
        for i in range(self.n_pos):
            self.cam.set_loc(self.cam_pos[i])
            self.cam.set_rot(self.cam_rot[i])
            individual_meas = self.cam.project_points(self.world_pts)
            meas[i*num_world_points:i*num_world_points + 8, :] = individual_meas
            meas_w_noise[i*num_world_points:i*num_world_points + 8, :] = individual_meas + ( np.random.randn(8,2) )
         

        return meas, meas_w_noise
        
    dskew = np.array([create_skew_symm_mat(np.array([1., 0., 0])),
                      create_skew_symm_mat(np.array([0., 1., 0])),
                      create_skew_symm_mat(np.array([0., 0., 1.]))])
    
    def compute_H(self):
        H = np.zeros((16,15))
         
        '''
        This takes the derivative of the project_points function w.r.t. R and t.
        dR is defined as a Skew Symmetric matrix as in utils.create_skew_symm_mat that
        is multiplied _to the right_ of c_R_w in the projection function.  In other words
        c_R_w(k+1) = c_R_w(k).dot(scipy.linalg.expm(utils.create_skew_symm_mat(dR)))
        and t is w_cam of the rotation

        Args:
            w_X: a 3-element vector representing the location of a point in the world
                coordinate frame
        
        Returns: a 2x15-element numpy array containing the derivatives of u,v w.r.t. dR,dt
        '''
        for i in range(self.world_pts.shape[0]):
            #doing projection as KR[I|-t]w_X
            dPX_dRt=np.zeros((3,6))
            
            #This code has been optimized for speed, not readability.... :(
            tmp_X = np.ones((4,))
            tmp_X[:3] = self.world_pts[i]

            KR = self.cam.K.dot(self.cam.c_R_w)
            w_diff = self.world_pts[i] - self.cam.w_cam
            PX = self.cam._P.dot(tmp_X)

            for ii in range(3):
                #It = np.hstack((np.eye(3),-self.w_cam.reshape((3,1))))
                dPX_dRt[:,ii] = KR.dot(self.dskew[ii].dot(w_diff))
            dPX_dRt[:,3:]=-KR
            #Now to handle the division to get to u,v
            going_out = np.zeros((2,6))
            going_out[0] = (dPX_dRt[0] - dPX_dRt[2]*PX[0]/PX[2])/PX[2]
            going_out[1] = (dPX_dRt[1] - dPX_dRt[2]*PX[1]/PX[2])/PX[2]
            H[i*2: i*2 + 2, :3] = going_out[:, :3]
            H[i*2: i*2 + 2, 6:9] = going_out[:, 3:]


        return H
    
    def f(self,idx):
        '''
        Propagate the "idx" timestep forward to predict its
        location at time idx+1

        Returns a tuple with (position, velocity, attitude, gyro bias, accel bias)
        '''
        g_bias = self.g_biases[idx] * (1-self.dt/self.gyro_tau)
        a_bias = self.a_biases[idx] * (1-self.dt/self.accel_tau)
        att= copy.copy(self.rotations[idx])
        vel = copy.copy(self.velocities[idx])
        pos = copy.copy(self.positions[idx])
        divider = 1
        my_dt = self.dt/float(divider)
        
        for i in range(divider):
            next_vel = vel + my_dt*(self.n_grav + att.T.dot(self.accels[idx]-self.a_biases[idx]))
            pos += (next_vel+vel)/2 * my_dt
            att = v2R(my_dt*(self.gyros[idx]-self.g_biases[idx])).dot(att)
            vel = next_vel
        # Just for kicks, though probably not needed
        att = to_rot(att)
        return (pos,vel,att,g_bias,a_bias)

    def compute_F(self,idx):
        '''
        Take self.positions[idx], velocities, etc and compute the F for 
        that state estimate

        Args: idx: which state vector to predict to idx+1

        Returns:
        A 15x30 numpy array
        '''
        F = np.zeros((15,30))
        # Easy first ... biases
        ## accels
        F[-3:,12:15] = (1-self.dt/self.accel_tau)*np.eye(3)
        F[-3:,-3:] = -np.eye(3)
        ## gyros
        F[-6:-3,9:12] = (1-self.dt/self.gyro_tau)*np.eye(3)
        F[-6:-3,-6:-3] = -np.eye(3)
        
        # Now for attitude
        ## The measurement is going to be 
        ## R2v(C_k^T C_gyro^T C_{k+1}(estimated))
        ## First take the derivative of the log w.r.t the whole matrix inside
        R_gyro = v2R(self.dt*(self.gyros[idx]-self.g_biases[idx]))
        big_R = self.cam_rot[idx].T.dot(R_gyro.T.dot(self.cam_rot[idx+1]))
        JR = J_logm(big_R)
        ## Now take the derivative of R w.r.t the state vector parts and 
        ## Do an element-by-element multiply with JR to get the complete derivative
        ### w.r.t. b_g
        for j in range(3):
            # The negative and the transpose cancel, I think...
            dbig_R_d_gyro = self.cam_rot[idx].T.dot(self.sss[j].dot(self.cam_rot[idx+1]))
            F[6:9,9+j] = log_J_to_vec(JR,self.dt*dbig_R_d_gyro)
        
        ### w.r.t C_k (estimated)
        for j in range(3):
            dbig_R_d_C_k = -self.sss[j].dot(big_R)
            F[6:9,6+j] = log_J_to_vec(JR,dbig_R_d_C_k)

        ### measurement w.r.t. C_{k+1} estimated
        for j in range(3):
            dbig_R_d_C_kp1 = big_R.dot(self.sss[j])
            F[6:9,21+j]= log_J_to_vec(JR,dbig_R_d_C_kp1)

        # Velocity!
        ## w.r.t. v_k
        F[3:6,3:6] = np.eye(3)
        D = np.eye(3) #v2R(self.dt/2. * (self.scen.gyros[idx]-self.g_biases[idx]))
        ## w.r.t. b_C_n
        for j in range(3):
            F[3:6,j+6] = -self.dt*\
                self.sss[j].dot(self.cam_rot[idx].T.dot(D.T).dot(self.accels[idx]-self.a_biases[idx]))
        ## w.r.t. gyro biases
        # for j in range(3):
        #     F[3:6,j+9] = (self.dt**2)/2.0*\
        #         self.cam_rot[idx].T.dot(self.sss[j]).dot(self.scen.accels[idx]-self.a_biases[idx])
        F[3:6,9:12] = np.zeros((3,3))
        ## w.r.t. accel biases.        
        F[3:6,12:15] = -self.dt*self.cam_rot[idx].T.dot(D.T)

        F[3:6,18:21] = -np.eye(3)

        # Position!
        ## w.r.t. x_k
        F[:3,:3] = np.eye(3)
        F[:3,15:18] = -np.eye(3)
        ## w.r.t v_k
        F[:3,3:6] = self.dt*np.eye(3)
        ## Take the velocity terms and multiply times 1/2 dt
        F[:3,6:15] = self.dt/2. * F[3:6,6:15]

        return F

    def compute_A(self):
        sense_meas = self.n_ts * self.world_pts.shape[0] * 2 # 35 positions, 8 measurements per, 2 values per meas 
        n_rows = sense_meas + (self.n_ts-1)*15 
        n_columns = self.n_ts * 15
        n_meas_entries = sense_meas * 15

        # Derivatives for measurments
        meas_entries = np.zeros(n_meas_entries)
        meas_rows = np.zeros(n_meas_entries)
        meas_cols = np.zeros(n_meas_entries)

        for i in range(self.n_ts):
            self.cam.set_loc(self.cam_pos[i])
            self.cam.set_rot(self.cam_rot[i])
            H = self.compute_H()
            meas_entries[(i*240) : (i*240)+240] = self.s_R_inv*H.flatten()
            offset = (i*16, i*15)
            rows, cols = create_ij(offset, H.shape)
            meas_rows[(i*240) : (i*240)+240] = rows
            meas_cols[(i*240) : (i*240)+240] = cols
        
        # Dynamics
        ds = 450 #dynamics size...
        n_dyn_entries = (self.n_ts-1)*ds
        dyn_entries = np.zeros(n_dyn_entries)
        dyn_rows = np.zeros(n_dyn_entries)
        dyn_cols = np.zeros(n_dyn_entries)
        
        for i in range(self.n_ts-1):
            F = self.s_Q_inv.dot(self.compute_F(i))
            offset = (sense_meas+i*15,i*15)
            rows,cols = create_ij(offset,F.shape)
            dyn_entries[i*450:i*450+450] = F.flatten()
            dyn_rows[i*450:i*450+450] = rows
            dyn_cols[i*450:i*450+450] = cols
        
        entries = np.concatenate((meas_entries,dyn_entries))
        sp_rows= np.concatenate((meas_rows,dyn_rows))
        sp_cols= np.concatenate((meas_cols,dyn_cols))
            
        return sp.csr_matrix((entries,(sp_rows,sp_cols)), shape=(n_rows,n_columns))
    
    def compute_Y(self):
        sens_meas = self.n_ts * self.world_pts.shape[0] * 2
        n_rows = sens_meas +(self.n_ts-1)*15

        meas, meas_w_noise = self.compute_h()

        y = np.zeros(n_rows)
        # Start with sensor measurements
        for i in range(self.n_ts):
            y[i*2:i*2+2]= self.s_R_inv*(meas[i] - meas_w_noise[i])
        
        # Now for dynamics measurements
        dyn_st = sens_meas 
        dyn_cost = np.zeros(15)
        for i in range(self.n_ts-1):
            pred_x = self.f(i)
            dyn_cost[:3] = pred_x[0]-self.positions[i+1]
            dyn_cost[3:6] = pred_x[1] - self.velocities[i+1]
            dyn_cost[6:9] = R2v(pred_x[2].T.dot(self.rotations[i+1]))
            dyn_cost[9:12] = pred_x[3] - self.g_biases[i+1]
            dyn_cost[12:15] = pred_x[4] - self.a_biases[i+1]
            y[dyn_st+i*15:dyn_st+i*15+15] = -self.s_Q_inv.dot(dyn_cost)

        return y
        
    
    def add_delta(self, delta):
        assert len(delta) == 15*self.n_ts
        for i in range(self.n_ts):
            si = i*15 # starting index
            self.positions[i] += delta[si:si+3]
            self.velocities[i] += delta[si+3:si+6]
            self.rotations[i] = self.rotations[i].dot(v2R(delta[si+6:si+9]))
            self.g_biases[i] += delta[si+9:si+12]
            self.a_biases[i] += delta[si+12:si+15]
        
def test_deriv(hwp, dx_idx,step=.001, a_tol=1E-5, r_tol=1E-3):
    '''Tests to make sure
    the create_A and create_y are doing 
    the same thing.

    Returns a tuple with:
    * A boolean saying whether it passed
    * the numerical derivative
    * the computed derivative
    '''
    A = hwp.compute_A()
    width = A.shape[1]
    dx = np.zeros(width)
    dx[dx_idx]= step
    y_orig=hwp.compute_Y()
    state_diff = copy.deepcopy(hwp)
    state_diff.add_delta(dx)
    y_next = state_diff.compute_Y()
    num_deriv = (y_orig-y_next)/step
    comp_deriv = A[:,dx_idx]
    if sp.issparse(comp_deriv):
        comp_deriv=comp_deriv.toarray().flatten()
    good = np.allclose(num_deriv,comp_deriv,atol=a_tol,rtol=r_tol)
    return (good,num_deriv,comp_deriv)




if __name__ == "__main__":

    curr_state = sim_world()

    #For testing derivatives...
    orig_n_ts = curr_state.n_ts
    curr_state.n_ts = 2 # Make this smaller for testing
    A = curr_state.compute_A()
    width = A.shape[1]
    for i in range(width):
        test_res = test_deriv(curr_state,i,.0001, a_tol=.1)
        if not test_res[0]:
            print('Error with derivative in column',i)
            print('absolute difference was :\n',np.abs(test_res[1]-test_res[2]))
            print('Computed derivative was:\n',test_res[2])
    curr_state.n_ts = orig_n_ts
    
    '''
    done = False
    num_iters = 0
    y = curr_state.compute_Y()
    while not done:
        print(f'Iteration: {num_iters}')
        A = curr_state.compute_A()
        # Using a sparse matrix
        AtA = A.T.dot(A)
        Aty = A.T.dot(y)
        delta_x = spla.spsolve(AtA, Aty)

        # Time for the fancy scaling stuff
        scale = 1
        scale_good = False
        while not scale_good:
            pred_y = y - A.dot(delta_x  * scale)
            next_state = copy.deepcopy(curr_state)
            next_state.add_delta(delta_x * scale)
            next_y = next_state.compute_Y()
            ratio = (y.dot(y) - next_y.dot(next_y)) / (y.dot(y) - pred_y.dot(pred_y))
            if ratio > 4 or ratio < 0.25:
                scale /= 2
                if scale < 0.01:
                    print(f'At scale: {scale}')
            else:
                scale_good = True
        curr_state = next_state
        y = next_y
        print(f'y is {la.norm(next_y)}, long, used scale, {scale}')
        num_iters += 1
        done = num_iters > 10 or la.norm(delta_x) < (0.001 * m.sqrt(curr_state.n_ts))
    
    x_true = curr_state.cam_pos[:curr_state.n_ts,0]
    y_true = curr_state.cam_pos[:curr_state.n_ts,1]
    z_true = curr_state.cam_pos[:curr_state.n_ts,2]
    x_est = curr_state.positions[:,0]
    y_est = curr_state.positions[:,1]
    z_est = curr_state.positions[:,2]
    
    ## Plot x-y
    plt.figure()
    plt.plot(x_true,y_true,label='truth')
    plt.plot(x_est,y_est,label='est')
    plt.legend()
    plt.title('X-Y')
    ## y-z
    plt.figure()
    plt.plot(y_true,z_true,label='truth')
    plt.plot(y_est,z_est,label='est')
    plt.legend()
    plt.title('Y-Z')
    ## errors
    plt.figure()
    plt.plot(x_est-x_true,label='X')
    plt.plot(y_est-y_true,label='Y')
    plt.plot(z_est-z_true,label='Z')
    plt.legend()
    plt.title('Location Errors')

    #Gyro biases?
    plt.figure()
    plt.plot(curr_state.g_biases)
    plt.title('Estimated Gyro biases over time')

    #Accel biases?
    plt.figure()
    plt.plot(curr_state.a_biases)
    plt.title('Estimated Accel biases over time')

    #Rotations
    rots = np.zeros((curr_state.n_ts,3))
    for i in range(curr_state.n_ts):
        rots[i] = R2v(curr_state.attitudes[i])
    plt.figure()
    plt.plot(rots)
    plt.title('Rotation estimates')
    

    #Rotation errors
    rot_errors = np.zeros((curr_state.n_ts,3))
    for i in range(curr_state.n_ts):
        rot_errors[i] = R2v(curr_state.cam_rot[i].T.dot(curr_state.attitudes[i]))
    plt.figure()
    plt.plot(rot_errors)
    plt.title('Rotation errors')
    
    
    plt.show()
    '''
